# ğŸ•µï¸â€â™‚ï¸ Super Easy Guide: Find Why Your Program is Running Slow!

Hello, young detective! ğŸ‘‹  
When your game, app, or website feels **super slow** like a sleepy turtle ğŸ¢, this guide helps you find the bad guy â€” step by step!

We use simple Linux commands like magic spells ğŸ”® to see what's wrong.

**The 3 main bad guys that make things slow:**
1. CPU is too busy thinking ğŸ§ ğŸ”¥  
2. Disk is super slow (like old hard drive) ğŸ’¾ğŸ˜´  
3. Program is waiting for something (network, database, locks) â³

Let's catch them!

## Quick Start â€“ What You Need
- A Linux computer or server
- Be able to open a terminal (black window)
- Most commands work without special permission

## Detective Steps â€“ Do Them in This Order
------------------------------------------------------------------------------------------------------------------
### 1. First Look: `top` (like looking through a big window)

```bash
top

Press 1 â†’ see each CPU separately
Press q â†’ quit
Sample output (top part only):
texttop - 07:15:22 up 5 days,  4:10,  1 user,  load average: 1.25, 1.10, 0.95
Tasks: 280 total,   2 running, 278 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.2 us, 42.3 sy,  0.0 ni, 35.1 id, 21.4 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  32768 total,   2200 free,  24500 used,   6068 buff/cache
Important things to watch (highlighted):

%id = 35.1 â†’ quite a lot of free time â†’ CPU is not the problem ğŸ˜Š
wa = 21.4 â†’ waiting for disk â†’ disk might be slow! ğŸš¨
Look at top processes â†’ high %CPU = busy program


------------------------------------------------------------------------------------------------------------------------

  2. Fast Health Check: vmstat 1
Bashvmstat 1
Sample output:
textprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0  1800k 12000 600000    0    0    20   120  150  520  1 42 35 22  0
 3  1      0  1750k 12100 601200    0    0   180   450  220  780  2 45 30 23  0
Important things to watch:

r â†’ number of programs waiting to run
â†’ Compare with your CPU count!
Run this to see how many CPUs you have:BashnprocExample: nproc shows 16 â†’ if r is always >20 â†’ CPU is too busy ğŸ˜“
wa â†’ high number = waiting for disk (bad!)
------------------------------------------------------------------------------------------------------------------------
3. Check Each CPU: mpstat -P ALL 1
Bashmpstat -P ALL 1
Sample output (short part):
text06:20:01 PM  CPU    %usr   %nice    %sys %iowait  %irq   %soft  %idle
06:20:02 PM  all    1.5     0.0   42.0    20.5   0.0    0.1   36.0
06:20:02 PM    0    2.0     0.0   41.0    18.0   0.0    0.0   39.0
06:20:02 PM    1    1.0     0.0   43.0    23.0   0.0    0.2   33.0
Important:

%iowait high on any CPU â†’ waiting for disk or network

------------------------------------------------------------------------------------------------------------------------
  4. MOST IMPORTANT â€“ Disk Check: iostat -x 1
Bashiostat -x 1
Sample output:
textDevice            r/s     w/s     rkB/s    wkB/s   rrqm/s   wrqm/s r_await w_await aqu-sz  %util
sda              150.0    60.0   6000.0   4800.0     5.0     12.0    3.8ms  15.2ms   2.1   **68.4**
sdb                8.0     3.0    300.0    200.0     0.0      0.0    0.9ms   1.2ms   0.2    4.5
Super important numbers:

%util â†’ >60% is bad, >80â€“90% is very bad â†’ disk is the slow villain! ğŸš¨
await â†’ big number (like >10â€“20 ms) = slow disk
aqu-sz > 2 â†’ long waiting line

------------------------------------------------------------------------------------------------------------------------
  5. Network Check: sar -n DEV 1
Bashsar -n DEV 1
Sample output:
text06:25:01 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   %ifutil
06:25:02 PM      eth0    2200.0    4500.0     280.0    5200.0      5.2
06:25:02 PM       lo      300.0     300.0      40.0      40.0      0.0
Important: %ifutil high (>70â€“80%) â†’ network is busy
------------------------------------------------------------------------------------------------------------------------

  6. Spy Inside the Program: strace
First find the program number (PID):
Bashps aux | grep your-app-name
Then spy:
Bashstrace -p 12345 -tt -T
Sample lines (look for big times!):
text[12345] 07:30:12.456789 **futex**(...) = ? **<18.765432>**   â† waited almost 19 seconds! ğŸ˜±
[12345] 07:30:31.222333 read(7, ...) = 4096 **<1.450000>**   â† waited 1.45 seconds
Or get summary (best!):
Bashstrace -p 12345 -c
Sample summary:
text% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 98.92    4.876543       48765       100           **futex**      â† 99% time here = lock problem!
  0.85    0.041234          41       100           read
------ ----------- ----------- --------- --------- ----------------
100.00    4.917777                 200           total
Big number in seconds or % time â†’ that's the bad guy!


------------------------------------------------------------------------------------------------------------------------

## ğŸ” Detective Summary â€“ At a Glance

| Step | Command               | ğŸš© Red Flag                              | Culprit                  |
|------|-----------------------|------------------------------------------|--------------------------|
| 1    | `top`                 | **wa** is high (>10â€“20%)                 | ğŸ’¾ Disk waiting          |
| 2    | `vmstat 1`            | **wa** high **OR** **r** > `nproc` value | ğŸ’¾ Disk or ğŸ§  CPU overload |
| 4 â˜…  | `iostat -x 1`         | **%util > 60%** (danger zone!)           | **ğŸ’¾ Disk bottleneck**   |
| 6    | `strace -p PID -c`    | Big %/seconds in **futex** / **read**    | â›“ï¸ Locks, ğŸ’¾ Disk, DB    |

**Pro move:** When CPUs look relaxed but app is slow â†’ jump straight to `iostat -x 1`!
  

